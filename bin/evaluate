#!/bin/bash
#
# Usage: executable [options...]
# Check the correctness and performance of an executable
#
# Options:
#  -s,--samp NUM --- only run NUM tests sampled at random
#  -p,--perf ------- test performance
#  -r,--repeat NUM - repeat run NUM times
#  -e,--event ------ select perf event to sample
#  -s,--size ------- return the size of the binary
#
. bin/common

PROG="$1"; shift
declare -A OUTPUTS
EXIT=0
SAMP=55
PERF=""
FAIL=""
REPT=""
EVNT=""
SIZE=""
SHORT="s:pr:e:S"
LONG="samp:,perf,repeat:,event:,size"
eval set -- $(getopt -o $SHORT -l $LONG -- "$@" || help;)
while [ $# -gt 0 ];do
    case $1 in
        -s|--samp) SAMP="$2"; shift;;
        -p|--perf) PERF="yes";;
        -r|--repeat) REPT="$2"; shift;;
        -e|--event) PERF="yes"; EVNT="$2"; shift;;
        -S|--size) SIZE="yes";;
        (--) shift; break;;
        (-*) error "unrecognized option $1";;
        (*)  break;;
    esac
    shift
done

exit_hook(){
    if [ ${#OUTPUTS[*]} -gt 1 ];then
        for key in ${!OUTPUTS[@]};do
            echo "${OUTPUTS[$key]},$key"
        done
        echo "$EXIT,exit"
    else
        echo ${OUTPUTS[*]}
    fi
    exit $EXIT; }
trap exit_hook EXIT

declare -a TESTS
for i in tests/*;do
    TESTS+=($(basename $i))
done

shuffle() {
    # http://stackoverflow.com/questions/5533569/
    # simple-method-to-shuffle-the-elements-of-an-array-in-bash-shell
   local i tmp size max rand
   size=${#TESTS[*]}
   max=$(( 32768 / size * size ))
   for ((i=size-1; i>0; i--)); do
      while (( (rand=$RANDOM) >= max )); do :; done
      rand=$(( rand % (i+1) ))
      tmp=${TESTS[i]}; TESTS[i]=${TESTS[rand]}; TESTS[rand]=$tmp
   done; }
shuffle

## Correctness
if [ $SAMP -gt 0 ];then
    OUTPUTS[passing]=$(
        for index in $(seq 0 $(($SAMP - 1))) ;do
            test=${TESTS[$index]}
            timeout 1 cat tests/$test \
                |$PROG|check <(sed 'N;s/\n/Î¾/' tests/$test) -
        done|grep -c PASS)
    if [ ! $SAMP -eq ${OUTPUTS[passing]} ];then
        EXIT=1
    fi
fi

## Performance
if [ ! -z $PERF ] && [ -z $FAIL ];then
    PERF_OUT=$(mktemp)
    SORT_OUT=$(mktemp)
    PERF="perf stat -x, -o $PERF_OUT"
    if [ ! -z $EVNT ];then PERF+=" -e $EVNT"; fi
    if [ ! -z $REPT ];then PERF+=" -r $REPT"; fi
    cat big-test|limit $PERF -- $PROG > $SORT_OUT
    ${BASE}/big-checker $SORT_OUT >/dev/null
    EXIT=$(($EXIT | $?))
    IFS="
"
    for line in $(cat $PERF_OUT|sed -n '3,$p');do
        OUTPUTS[$(echo "$line"|cut -d, -f2)]=$(echo "$line"|cut -d, -f1)
    done
fi

## Size
if [ ! -z $SIZE ];then
    OUTPUTS[size]=$(wc -c $PROG|cut -d' ' -f1)
fi
